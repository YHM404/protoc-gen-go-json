package gen

import (
	"io"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// Options are the options to set for rendering the template.
type Options struct {
	EnumsAsInts        bool
	EmitDefaults       bool
	EmitDefaultValues  bool
	OrigName           bool
	AllowUnknownFields bool
	GenerateBinary     bool
	GenerateMarshal    bool
	GenerateUnmarshal  bool
}

// This function is called with a param which contains the entire definition of a method.
func ApplyTemplate(g *protogen.GeneratedFile, f *protogen.File, opts *Options) error {
	const (
		syntaxFieldNumber  = 12
		packageFieldNumber = 2
	)
	genStandaloneComments(g, f, syntaxFieldNumber)
	g.P("// Code generated by protoc-gen-go-json. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P()
	genStandaloneComments(g, f, packageFieldNumber)
	if err := headerTemplate.Execute(g, tplHeader{
		File: f,
	}); err != nil {
		return err
	}
	return applyMessages(g, f.Messages, opts)
}

func ApplyBinaryTemplate(g *protogen.GeneratedFile, f *protogen.File, opts *Options) error {
	const (
		syntaxFieldNumber  = 12
		packageFieldNumber = 2
	)
	genStandaloneComments(g, f, syntaxFieldNumber)
	g.P("// Code generated by protoc-gen-go-json. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P()
	genStandaloneComments(g, f, packageFieldNumber)
	if err := binaryHeaderTemplate.Execute(g, tplHeader{
		File: f,
	}); err != nil {
		return err
	}
	return applyBinaryMessages(g, f.Messages, opts)
}

func applyMessages(w io.Writer, msgs []*protogen.Message, opts *Options) error {
	for _, m := range msgs {
		if m.Desc.IsMapEntry() {
			continue
		}
		if err := messageTemplate.Execute(w, tplMessage{
			Message: m,
			Options: opts,
		}); err != nil {
			return err
		}
		if err := applyMessages(w, m.Messages, opts); err != nil {
			return err
		}
	}
	return nil
}

func applyBinaryMessages(w io.Writer, msgs []*protogen.Message, opts *Options) error {
	for _, m := range msgs {
		if m.Desc.IsMapEntry() {
			continue
		}
		if opts.GenerateMarshal && opts.GenerateUnmarshal {
			if err := binaryMessageTemplate.Execute(w, tplBinaryMessage{
				Message: m,
			}); err != nil {
				return err
			}
		} else if opts.GenerateMarshal {
			if err := binaryMarshalTemplate.Execute(w, tplBinaryMessage{
				Message: m,
			}); err != nil {
				return err
			}
		} else if opts.GenerateUnmarshal {
			if err := binaryUnmarshalTemplate.Execute(w, tplBinaryMessage{
				Message: m,
			}); err != nil {
				return err
			}
		}

		if err := applyBinaryMessages(w, m.Messages, opts); err != nil {
			return err
		}
	}
	return nil
}

type tplHeader struct {
	*protogen.File
}

type tplMessage struct {
	*protogen.Message
	*Options
}

type tplBinaryMessage struct {
	*protogen.Message
}

var (
	headerTemplate = template.Must(template.New("header").Parse(`
package {{.GoPackageName}}

import (
	"google.golang.org/protobuf/encoding/protojson"
)
`))

	messageTemplate = template.Must(template.New("message").Parse(`
// MarshalJSON implements json.Marshaler
func (msg *{{.GoIdent.GoName}}) MarshalJSON() ([]byte,error) {
	return protojson.MarshalOptions {
		{{- if .EnumsAsInts}}
		UseEnumNumbers: {{.EnumsAsInts}},
		{{- end}}
		{{- if .EmitDefaults}}
		EmitUnpopulated: {{.EmitDefaults}},
		{{- end}}
		{{- if .OrigName}}
		UseProtoNames: {{.OrigName}},
		{{- end}}
		{{- if .EmitDefaultValues}}
		EmitDefaultValues: {{.EmitDefaultValues}},
		{{- end}}
	}.Marshal(msg)
}

// UnmarshalJSON implements json.Unmarshaler
func (msg *{{.GoIdent.GoName}}) UnmarshalJSON(b []byte) error {
	return protojson.UnmarshalOptions {
		{{- if .AllowUnknownFields}}
		DiscardUnknown: {{.AllowUnknownFields}},
		{{- end}}
	}.Unmarshal(b, msg)
}
`))

	// 二进制序列化文件的头部模板
	binaryHeaderTemplate = template.Must(template.New("binary_header").Parse(`
package {{.GoPackageName}}

import (
	"google.golang.org/protobuf/proto"
)
`))

	binaryMessageTemplate = template.Must(template.New("binary_message").Parse(`
// Marshal marshals the message using proto.Marshal
func (msg *{{.GoIdent.GoName}}) Marshal() ([]byte, error) {
	return proto.Marshal(msg)
}

// Unmarshal unmarshals the message using proto.Unmarshal
func (msg *{{.GoIdent.GoName}}) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, msg)
}
`))

	binaryMarshalTemplate = template.Must(template.New("binary_marshal").Parse(`
// Marshal marshals the message using proto.Marshal
func (msg *{{.GoIdent.GoName}}) Marshal() ([]byte, error) {
	return proto.Marshal(msg)
}
`))

	binaryUnmarshalTemplate = template.Must(template.New("binary_unmarshal").Parse(`
// Unmarshal unmarshals the message using proto.Unmarshal
func (msg *{{.GoIdent.GoName}}) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, msg)
}
`))
)

// genStandaloneComments prints all leading comments for a FileDescriptorProto location identified
// by the field number n. It is used to print the comments that are not attached to any specific
// element in the file, such as the file itself (12) or package declaration (2).
//
// This function is copied from the protoc-gen-go source code.
//
// https://github.com/protocolbuffers/protobuf-go/blob/v1.33.0/LICENSE
func genStandaloneComments(g *protogen.GeneratedFile, f *protogen.File, n int32) {
	loc := f.Desc.SourceLocations().ByPath(protoreflect.SourcePath{n})
	for _, s := range loc.LeadingDetachedComments {
		g.P(protogen.Comments(s))
		g.P()
	}
	if s := loc.LeadingComments; s != "" {
		g.P(protogen.Comments(s))
		g.P()
	}
}
